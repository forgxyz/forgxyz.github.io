---
title: Aggregations Part 2
description: Advanced aggregations in SQL.
course: sql-101
segment: Title TBD
segment_id: 1
lesson: advanced-aggregations
lesson_id: 1
---

# SQL, Aggregated

Great! We can calculate some stats and metrics across our result set. But, we often want to see what's happening _within_ the set, both over time and across groups. Enter `GROUP BY`.

## GROUP BY

Let's build on the code we used in the previous page, specifically the opensea sales.

In that example we just used `where currency = ETH`, and got was most of the sales for June... but we don't just want "most" because that's a bit too convenient an approach.

So, instead of excluding everything and just filtering to ETH, we can instead use `GROUP BY` to `SUM` within groups:

```sql
SELECT 
    currency_symbol,
    SUM(platform_fee) AS total_platform_fee,
    SUM(platform_fee_usd) AS total_platform_fees_usd
FROM ethereum.core.ez_nft_sales
WHERE block_timestamp::DATE BETWEEN '2022-06-01' AND '2022-06-30'
    AND platform_name = 'opensea'
    GROUP BY 1
    ORDER BY 1 DESC;
```

{% capture hint_content %}
As mentioned, presentation is not the only purpose of visualization tools. They can seriously help us in our analytical process, and can spark curiosity as we work through data.
{% endcapture %}
{% include hint.html type="info" title="Using Visualizations in Our Analytical Process" content=hint_content %}

In this case, `GROUP BY 1` indicates that the grouping should happen on the first column, which is `currency_symbol`. In a most basic sense, group by "squishes" results into the proper groups. So, wherever `currency_symbol = 'ETH'`, those records will be summed up together. Using `GROUP BY` over our prior method means we are not excluding the records where the currency is not ETH. The fees generated by those sales are included in records of their own category!

But, still, we can get more granular and begin to look at patterns.

### HAVING

We can filter our aggregated results, but not with `WHERE` ! That will apply to the query, still, in that the parameters within the where clause impact the result set.

We then use `GROUP BY` and aggregation functions to compute something over that result set. But, what if we wanted to limit those results to exclude outliers, or to hone in on a specific band of volume. We can filter the aggregated results with `HAVING`.

If you ran the above code, you'll notice a lot of small-dollar, random, or null values for some of the currencies. We may want to exclude these from the analysis, if deemed appropriate.

```sql
SELECT 
    DATE_TRUNC('day', block_timestamp) AS _date,
    currency_symbol,
    SUM(platform_fee) AS total_platform_fee,
    SUM(platform_fee_usd) AS total_platform_fees_usd
FROM ethereum.core.ez_nft_sales
WHERE block_timestamp::DATE BETWEEN '2022-06-01' AND '2022-06-30'
    AND platform_name = 'opensea'
    GROUP BY 1, 2
    HAVING total_platform_fees_usd > 1000
    ORDER BY 1, 4 DESC;
```

Notice here we use `GROUP BY 1, 2` - per above we should be able to infer that this is:

* creating a group based on date
* creating a group based on currency, within each date

$1,000 was selected fairly arbitrarily, it's up to the analyst and the purpose behind setting these parameters!

{% capture hint_content %}
Confused about what goes where? Not a problem, there's a lot to keep track of! Of the concepts we've learned _so far_, here's the order of operations for how you should structure your query:

1. `SELECT`
2. `FROM`
3. `WHERE`
4. `GROUP BY`
5. `HAVING`
6. `ORDER BY`

Think about it in clusters:

* First we have to get the data and create our result set `SELECT FROM WHERE`
* then we might want to do something to that result set- transform it in some way `GROUP BY HAVING`
* finally, we might want to stay organized so we`ORDER BY`

[Read more here](https://mode.com/sql-tutorial/sql-having/#query-clause-order)
{% endcapture %}
{% include hint.html type="warning" title="Order of Operations" content=hint_content %}

## [DATE\_TRUNC](https://docs.snowflake.com/en/sql-reference/functions/date\_trunc.html)

We can even use this `GROUP BY` on dates! Say we want to visualize these sales over time, whether it be day, week, quarter, etc. We can use a special date & time function to truncate the `block_timestamp` to a desired precision.

Let's revise the above query to look at daily fee volume on OpenSea:

```sql
SELECT 
    DATE_TRUNC('week', block_timestamp) as _date,
    currency_symbol,
    SUM(platform_fee) AS total_platform_fee,
    SUM(platform_fee_usd) AS total_platform_fees_usd
FROM ethereum.core.ez_nft_sales
WHERE block_timestamp::DATE BETWEEN '2022-01-01' AND '2022-06-30'
    AND platform_name = 'opensea'
    GROUP BY 1, 2
    ORDER BY 1, 4 DESC;
```

`DATE_TRUNC` is quite dynamic and can help us look at a wide variety of time slices, using any of the supported [date / time parts](https://docs.snowflake.com/en/sql-reference/functions-date-time.html#label-supported-date-time-parts)!

## CASE Statements

We can replace data if we don't like it. No, not in the manipulate the numbers sense! In our fee analysis thus far, we have some 20+ currencies accounting for <1% of OpenSea fee revenue and that makes for a really messy outcome. So, let's lump those all into an "other group" by replacing everything that we don't want from within `currency_symbol`.

CASE statements are if conditionals, but we use the keyword `WHEN` instead of `IF`.

* _when not where - this can be easy to mix up in your head early on!_

The basic structure of a case statement is:

```sql
CASE -- declare the start of a case statement
  WHEN <conditional statement> THEN <outcome> -- if the conditional statement evaluates to true, the <outcome> will be used
  WHEN <conditional statement> THEN <outcome>
  ELSE <outcome> -- optional line to include as a "catch-all"
END AS <alias> -- declare the end of a case statement and alias the column name
```

The result of a case statement is a column, hence the `<alias>`, but what is happening? We are replacing the contents of a column, based on some parameters.

In our example, we want to keep a select few currencies, and change every other currency to "Other"

```sql
SELECT 
    DATE_TRUNC('day', block_timestamp) AS _date,
    CASE
  	WHEN currency_symbol = 'ETH' THEN currency_symbol
  	WHEN currency_symbol = 'WETH' THEN currency_symbol
  	WHEN currency_symbol = 'USDC' THEN currency_symbol
  	ELSE 'Other'
    END AS currency_symbol,
    SUM(platform_fee) AS total_platform_fee,
    SUM(platform_fee_usd) AS total_platform_fees_usd
FROM ethereum.core.ez_nft_sales
WHERE block_timestamp::DATE BETWEEN '2022-06-01' AND '2022-06-30'
    AND platform_name = 'opensea'
    GROUP BY 1, 2
    ORDER BY 1, 4 DESC;
```

Notice above, the outcome of `WHEN currency_symbol = desired currency` is the column `currency_symbol` while the outcome for `ELSE` is a string `'Other'`. In plain terms, we're saying when currency\_symbol is ETH, WETH, or USDC take the value in the column. For everything else, use this string, `'Other'`, instead.
